# Write-Ups

Day 1:

- honestly wasn't all that difficult
- adapting script for day 2 was a bit of effort but honestly took like 2 minutes

Day 2:

- literally wasn't difficult at all
- just the addition of a third variable was all it took to complete part 2

Day 3:

- ok this one was actually difficult
- i had to rewrite the entire program to satisfy part 2
- one of the things i like is utilizing the very little things about python that i almost never use on a daily basis, solely for the purpose of optimizing these

Day 4:

- literally had to write **part 1** twice just for it to work
- first attempt was really complex
- second attempt was held together with spit and gum
- once part 1 worked, i had to take what i wrote apart so that i could reverse the whole process
- took literal hours to complete

Day 5:

- was going back and forth on using numpy
- constantly got memoryerrors because there was just too much data
- had to rewrite multiple times
- ultimately reused part 1 solution for part 2 but slightly modified it

Day 6:

- way too easy
- incredibly easier than days 4 and 5
- i think i was just graced with the idea of using a dictionary as early as i did

Day 7:

- lmao what was this
- (i've been informed that weekend problems are made intentionally harder than weekday problems)
- still this one was way too easy
- a lot easier than day 6's
- but **i've finally completed a whole week!**

Day 8:

- i like to call this one `"list comprehension ad nauseum"`
- day 1 was really easy
- day 2 was much more difficult but still fun
- works by first attempting to solve for each individual segment, then building each digit from the segments it uses

Day 9:

- i was _going_ to complete it within an hour after it was released
- but i couldn't figure out how to get the top 3 items in a list
- (also the recursive branch function i had beforehand wasn't working)
- so i implemented my own

Day 10:

- **10 DAYS LETS GO**
- also really easy
- finished in 11 minutes
- so i finally achieved my goal of completing a day in the first hour it was given

Day 11:

- day 2 was super easy
- just had to add an extra variable and change some stuff
- recurring theme is "it doesn't look pretty but it works"

Day 12:

- pretty easy
- see i hate pathfinding algorithms so i thought today was going to be absolute hell
- but then i gave it a shot and it turned out pretty well
- (runs a bit slowly)
- **reached 12 days of completely vanilla solutions**

Day 13:

- was somewhat difficult as the phrase `The manual says the code is always eight capital letters.` was hard to understand
- still managed to finish

BONUS:

- i got a bonus challenge as part of a competition for discord nitro/$100 steam credit
- so i decided to do it
- i included it here because it's somewhat similar
- (i think i was the first person to finish)
- will optimize later

Day 14:

- hell
- on earth
- part 1 was fine but part 2 was awful

Day 15:

- well
- i hate to say it
- but i've officially conceded the full vanilla challenge
- there's no easy way to make a priority queue without using `queue.PriorityQueue`
- `Day 15 Part 2 Vanilla.py` has an implementation written without `queue.PriorityQueue`, it just doesn't run in reasonable time

Day 16:

- before today, i'd consider some of the solutions i've made this year unnecessarily complicated and overengineered, but not bad
- today i have created the first **bad** solution of the year
- and it only took 11 hours, 5+ people and a third-party decoder/interpreter
- god i hate opcode

Day 17:

- by some miracle
- brute forcing worked
- and [the math](https://www.reddit.com/r/adventofcode/comments/rid2jc/2021_day_17pencil_my_best_visualisation_so_far_i/) looked way too complex for me
- because im not in physics
- so i resorted to brute forcing, because why not

Day 18:

- either i'm a genius
- or i'm completely crazy
- every snailfish is parsed as a string rather than nested lists
- and by some miracle part 2 runs in a minute
