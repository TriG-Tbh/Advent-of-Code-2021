# Write-Ups

Day 1:

- honestly wasn't all that difficult
- adapting script for day 2 was a bit of effort but honestly took like 2 minutes

Day 2:

- literally wasn't difficult at all
- just the addition of a third variable was all it took to complete part 2

Day 3:

- ok this one was actually difficult
- i had to rewrite the entire program to satisfy part 2
- one of the things i like is utilizing the very little things about python that i almost never use on a daily basis, solely for the purpose of optimizing these

Day 4:

- literally had to write **part 1** twice just for it to work
- first attempt was really complex
- second attempt was held together with spit and gum
- once part 1 worked, i had to take what i wrote apart so that i could reverse the whole process
- took literal hours to complete

Day 5:

- was going back and forth on using numpy
- constantly got memoryerrors because there was just too much data
- had to rewrite multiple times
- ultimately reused part 1 solution for part 2 but slightly modified it

Day 6:

- way too easy
- incredibly easier than days 4 and 5
- i think i was just graced with the idea of using a dictionary as early as i did

Day 7:

- lmao what was this
- (i've been informed that weekend problems are made intentionally harder than weekday problems)
- still this one was way too easy
- a lot easier than day 6's
- but **i've finally completed a whole week!**

Day 8:

- i like to call this one `"list comprehension ad nauseum"`
- day 1 was really easy
- day 2 was much more difficult but still fun
- works by first attempting to solve for each individual segment, then building each digit from the segments it uses

Day 9:

- i was _going_ to complete it within an hour after it was released
- but i couldn't figure out how to get the top 3 items in a list
- (also the recursive branch function i had beforehand wasn't working)
- so i implemented my own

Day 10:

- **10 DAYS LETS GO**
- also really easy
- finished in 11 minutes
- so i finally achieved my goal of completing a day in the first hour it was given

Day 11:

- day 2 was super easy
- just had to add an extra variable and change some stuff
- recurring theme is "it doesn't look pretty but it works"

Day 12:

- pretty easy
- see i hate pathfinding algorithms so i thought today was going to be absolute hell
- but then i gave it a shot and it turned out pretty well
- (runs a bit slowly)
- **reached 12 days of completely vanilla solutions**

Day 13:

- was somewhat difficult as the phrase `The manual says the code is always eight capital letters.` was hard to understand
- still managed to finish

Day 14:

- hell
- on earth
- part 1 was fine but part 2 was awful

Day 15:

- ~~well~~
- ~~i hate to say it~~
- ~~but i've officially conceded the full vanilla challenge~~
- ~~there's no easy way to make a priority queue without using `queue.PriorityQueue`~~
- ~~`Day 15 Part 2 Vanilla.py` has an implementation written without `queue.PriorityQueue`, it just doesn't run in reasonable time~~
- **UPDATE (12/20)**: thanks to the amazing xelf over at pydis, this **can** be done in a reasonable time completely vanilla by using dijkstra instead of a\*
- it takes an extremely long time to finish (2 hours 44 minutes 18 seconds to be exact), but it can finish in time

Day 16:

- before today, i'd consider some of the solutions i've made this year unnecessarily complicated and overengineered, but not bad
- today i have created the first **bad** solution of the year
- and it only took 11 hours, 5+ people and a third-party decoder/interpreter
- god i hate opcode

Day 17:

- by some miracle
- brute forcing worked
- and [the math](https://www.reddit.com/r/adventofcode/comments/rid2jc/2021_day_17pencil_my_best_visualisation_so_far_i/) looked way too complex for me
- because im not in physics
- so i resorted to brute forcing, because why not

Day 18:

- either i'm a genius
- or i'm completely crazy
- every snailfish is parsed as a string rather than nested lists
- and by some miracle part 2 runs in a minute

Day 19:

- so these last few days i've been abusing the soft time limits
- this one runs in about 3 minutes
- and i somehow managed to complete it without using numpy

Day 20:

- today took way too long
- 5 hours to complete, 15-20 minutes to run each file
- due to a difference between the sample and puzzle inputs, today's files are split up into sample-compatible files and puzzle-compatible files

Day 21:

- giant shoutout to mustafa at pydis for optimizing this
- this one was dumb, confusing, and nearly crashed my system 3 times
- part 2 was significantly harder than part 1

Day 22:

- this is probably the first day that i am completely unsatisfied with my answer
- part 2 was so difficult to understand that i had to look at someone else's answer to understand it
- and only after completing the problem and looking at their answer multiple times over did i truly understand it
- but i'm not a fan of having to use someone else's solution to understand the problem
- it feels like cheating, kinda
- but now i understand the problem, i know what it was asking for, and i know how to implement a solution (or similar solutions in the future)

Day 23:

- oops! no code
- today's parts were done almost entirely by hand, with the help of someone else's solution to give the first few steps needed to solve part 2
- one thing that was made extremely apparent today is that in a lot of instances, i just need a bit of a nudge to start the process to get to the final answer
- and often i'm missing that initial push because i chose to make this year harder for myself than it should be (full vanilla, 24 hour completion time)
- as i'm missing available resources + setting a relatively short time limit, which increase stress
- something that i'm going to do _next_ year is not apply these extreme constraints for myself, because they end up causing me to fail
- in the same vein as day 22, i'm a little unsatisfied that i had to look at someone else's answer to understand their thinking
- but after implementing it myself, i was able to understand the problem better
- now i'm better prepared for future problems
- perhaps the dissatisfaction stems from stubbornness? that i couldn't complete a day 100% on my own

Day 24:

- once again, thank you [mustafa](https://github.com/mustafaquraish) for making this 100 times easier to understand
- today i've learned that i can understand logic better if it's written in (roughly) the same style as python code
- i've also learned that these hard problems can be interpreted better by just manually taking an input and going through all the required steps
- now that i think about it, something similar could (or should) have been done with day 20
- but after 24 days, i've finally made it

BONUS:

- on 12/13 i got a bonus challenge as part of a competition for discord nitro/$100 steam credit
- so i decided to do it
- i included it here because it's somewhat similar
- (i think i was the first person to finish)
- between 12/13 and 12/20 i optimized it so much that i managed to cut down its execution time down to 16.5% of what it was originally
